import { ModuleMetadata, QueryMetadata, MutationMetadata } from './astAnalyzer';

export interface GeneratedStore {
  fileName: string;
  content: string;
}

/**
 * Generates zustand stores for all modules
 */
export function generateZustandStores(modules: ModuleMetadata[]): GeneratedStore[] {
  return modules.map((module) => generateStoreForModule(module));
}

/**
 * Generates a zustand store for a single module
 */
function generateStoreForModule(module: ModuleMetadata): GeneratedStore {
  const storeName = toPascalCase(module.name);
  const hookName = `use${storeName}Store`;

  const queriesSection = generateQueriesSection(module.queries);
  const mutationsSection = generateMutationsSection(module.mutations);

  const content = `// Generated by Modelence - DO NOT EDIT MANUALLY
import { create } from 'zustand';
import { callMethod } from 'modelence/client';

export const ${hookName} = create((set, get) => ({
${queriesSection.dataFields}
${mutationsSection.dataFields}

${queriesSection.implementations}
${mutationsSection.implementations}
}));
`;

  return {
    fileName: `${module.name}.ts`,
    content,
  };
}

interface SectionContent {
  dataFields: string;
  implementations: string;
}

function generateQueriesSection(queries: QueryMetadata[]): SectionContent {
  if (queries.length === 0) {
    return {
      dataFields: '',
      implementations: '',
    };
  }

  const dataFields = queries
    .map((q) => {
      const returnType = q.returnType || 'unknown';
      return `  ${q.name}Data: null as ${returnType} | null,`;
    })
    .join('\n');

  const implementations = queries
    .map((q) => {
      const argsType = q.argsType || 'Record<string, unknown>';
      return `  ${q.name}: async (args = {} as ${argsType}) => {
    const result = await callMethod('${q.fullName}', args);
    set({ ${q.name}Data: result });
    return result;
  },`;
    })
    .join('\n');

  return {
    dataFields,
    implementations,
  };
}

function generateMutationsSection(mutations: MutationMetadata[]): SectionContent {
  if (mutations.length === 0) {
    return {
      dataFields: '',
      implementations: '',
    };
  }

  const dataFields = mutations
    .map((m) => {
      const returnType = m.returnType || 'unknown';
      return `  ${m.name}Data: null as ${returnType} | null,`;
    })
    .join('\n');

  const implementations = mutations
    .map((m) => {
      const argsType = m.argsType || 'Record<string, unknown>';
      return `  ${m.name}: async (args = {} as ${argsType}) => {
    const result = await callMethod('${m.fullName}', args);
    set({ ${m.name}Data: result });
    return result;
  },`;
    })
    .join('\n');

  return {
    dataFields,
    implementations,
  };
}

/**
 * Convert a string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

/**
 * Generate an index file that exports all stores
 */
export function generateIndexFile(modules: ModuleMetadata[]): string {
  const exports = modules
    .map((module) => {
      const storeName = toPascalCase(module.name);
      const hookName = `use${storeName}Store`;
      return `export { ${hookName} } from './${module.name}';`;
    })
    .join('\n');

  return `// Generated by Modelence - DO NOT EDIT MANUALLY
/**
 * Auto-generated zustand stores for all modules
 * Import these stores in your client-side code to interact with the server
 */

${exports}
`;
}
