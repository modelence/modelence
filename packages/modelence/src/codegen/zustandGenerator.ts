import { ModuleMetadata, QueryMetadata, MutationMetadata } from './astAnalyzer';

export interface GeneratedStore {
  fileName: string;
  content: string;
}

/**
 * Generates zustand stores for all modules
 */
export function generateZustandStores(modules: ModuleMetadata[]): GeneratedStore[] {
  return modules.map((module) => generateStoreForModule(module));
}

/**
 * Generates a zustand store for a single module
 */
function generateStoreForModule(module: ModuleMetadata): GeneratedStore {
  const storeName = toPascalCase(module.name);
  const hookName = `use${storeName}Store`;

  const queriesSection = generateQueriesSection(module.queries);
  const mutationsSection = generateMutationsSection(module.mutations);

  const content = `// Generated by Modelence - DO NOT EDIT MANUALLY
import { create } from 'zustand';
import { callMethod } from 'modelence/client';

/**
 * Zustand store for ${module.name} module
 * Auto-generated from module queries and mutations
 */

// Create the store
export const ${hookName} = create((set, get) => ({
  // Query implementations
${queriesSection.implementations}

  // Mutation implementations
${mutationsSection.implementations}
}));
`;

  return {
    fileName: `${module.name}.ts`,
    content,
  };
}

interface SectionContent {
  implementations: string;
}

function generateQueriesSection(queries: QueryMetadata[]): SectionContent {
  if (queries.length === 0) {
    return {
      implementations: '  // No queries',
    };
  }

  const implementations = queries
    .map((q) => {
      const argsType = q.argsType || 'Record<string, unknown>';
      return `  ${q.name}: async (args = {} as ${argsType}) => callMethod('${q.fullName}', args),`;
    })
    .join('\n');

  return {
    implementations,
  };
}

function generateMutationsSection(mutations: MutationMetadata[]): SectionContent {
  if (mutations.length === 0) {
    return {
      implementations: '  // No mutations',
    };
  }

  const implementations = mutations
    .map((m) => {
      const argsType = m.argsType || 'Record<string, unknown>';
      return `  ${m.name}: async (args = {} as ${argsType}) => callMethod('${m.fullName}', args),`;
    })
    .join('\n');

  return {
    implementations,
  };
}

/**
 * Convert a string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

/**
 * Generate an index file that exports all stores
 */
export function generateIndexFile(modules: ModuleMetadata[]): string {
  const exports = modules
    .map((module) => {
      const storeName = toPascalCase(module.name);
      const hookName = `use${storeName}Store`;
      return `export { ${hookName} } from './${module.name}';`;
    })
    .join('\n');

  return `// Generated by Modelence - DO NOT EDIT MANUALLY
/**
 * Auto-generated zustand stores for all modules
 * Import these stores in your client-side code to interact with the server
 */

${exports}
`;
}
