import { ModuleMetadata, QueryMetadata, MutationMetadata } from './astAnalyzer';

export interface GeneratedStore {
  fileName: string;
  content: string;
  typesContent: string;
}

/**
 * Generates zustand stores for all modules
 */
export function generateZustandStores(modules: ModuleMetadata[]): GeneratedStore[] {
  return modules.map((module) => generateStoreForModule(module));
}

/**
 * Generates a zustand store for a single module
 */
function generateStoreForModule(module: ModuleMetadata): GeneratedStore {
  const storeName = toPascalCase(module.name);
  const hookName = `use${storeName}Store`;

  const queriesSection = generateQueriesSection(module.queries);
  const mutationsSection = generateMutationsSection(module.mutations);

  const content = `// Generated by Modelence - DO NOT EDIT MANUALLY
import { create } from 'zustand';
import { callMethod } from 'modelence/client';

/**
 * Zustand store for ${module.name} module
 * Auto-generated from module queries and mutations
 */

// Query methods
${queriesSection.methods}

// Mutation methods
${mutationsSection.methods}

// Store interface
interface ${storeName}Store {
  // Queries
${queriesSection.interface}

  // Mutations
${mutationsSection.interface}
}

// Create the store
export const ${hookName} = create<${storeName}Store>((set, get) => ({
  // Query implementations
${queriesSection.implementations}

  // Mutation implementations
${mutationsSection.implementations}
}));
`;

  const typesContent = `// Generated by Modelence - DO NOT EDIT MANUALLY

/**
 * Type definitions for ${module.name} module store
 */

// Query argument types
${queriesSection.types}

// Mutation argument types
${mutationsSection.types}

// Query return types - these should be manually typed or inferred from the server
${queriesSection.returnTypes}

// Mutation return types - these should be manually typed or inferred from the server
${mutationsSection.returnTypes}
`;

  return {
    fileName: `${module.name}.ts`,
    content,
    typesContent,
  };
}

interface SectionContent {
  methods: string;
  interface: string;
  implementations: string;
  types: string;
  returnTypes: string;
}

function generateQueriesSection(queries: QueryMetadata[]): SectionContent {
  if (queries.length === 0) {
    return {
      methods: '// No queries defined',
      interface: '  // No queries',
      implementations: '  // No queries',
      types: '// No queries',
      returnTypes: '// No queries',
    };
  }

  const methods = queries
    .map((q) => {
      const argsType = q.argsType || 'Record<string, unknown>';
      return `/**
 * Query: ${q.name}
 * Call the ${q.fullName} method on the server
 */
async function ${q.name}(args: ${argsType} = {} as ${argsType}) {
  return callMethod('${q.fullName}', args);
}`;
    })
    .join('\n\n');

  const interfaceDef = queries
    .map((q) => {
      const argsType = q.argsType || 'Record<string, unknown>';
      const returnType = q.returnType || 'unknown';
      return `  ${q.name}: (args?: ${argsType}) => Promise<${returnType}>;`;
    })
    .join('\n');

  const implementations = queries
    .map((q) => {
      const argsType = q.argsType || 'Record<string, unknown>';
      return `  ${q.name}: async (args = {} as ${argsType}) => callMethod('${q.fullName}', args),`;
    })
    .join('\n');

  const types = queries
    .map((q) => {
      const argsType = q.argsType || 'Record<string, unknown>';
      return `export type ${toPascalCase(q.name)}Args = ${argsType};`;
    })
    .join('\n');

  const returnTypes = queries
    .map((q) => {
      const returnType = q.returnType || 'unknown';
      return `export type ${toPascalCase(q.name)}Result = ${returnType};`;
    })
    .join('\n');

  return {
    methods,
    interface: interfaceDef,
    implementations,
    types,
    returnTypes,
  };
}

function generateMutationsSection(mutations: MutationMetadata[]): SectionContent {
  if (mutations.length === 0) {
    return {
      methods: '// No mutations defined',
      interface: '  // No mutations',
      implementations: '  // No mutations',
      types: '// No mutations',
      returnTypes: '// No mutations',
    };
  }

  const methods = mutations
    .map((m) => {
      const argsType = m.argsType || 'Record<string, unknown>';
      return `/**
 * Mutation: ${m.name}
 * Call the ${m.fullName} method on the server
 */
async function ${m.name}(args: ${argsType} = {} as ${argsType}) {
  return callMethod('${m.fullName}', args);
}`;
    })
    .join('\n\n');

  const interfaceDef = mutations
    .map((m) => {
      const argsType = m.argsType || 'Record<string, unknown>';
      const returnType = m.returnType || 'unknown';
      return `  ${m.name}: (args?: ${argsType}) => Promise<${returnType}>;`;
    })
    .join('\n');

  const implementations = mutations
    .map((m) => {
      const argsType = m.argsType || 'Record<string, unknown>';
      return `  ${m.name}: async (args = {} as ${argsType}) => callMethod('${m.fullName}', args),`;
    })
    .join('\n');

  const types = mutations
    .map((m) => {
      const argsType = m.argsType || 'Record<string, unknown>';
      return `export type ${toPascalCase(m.name)}Args = ${argsType};`;
    })
    .join('\n');

  const returnTypes = mutations
    .map((m) => {
      const returnType = m.returnType || 'unknown';
      return `export type ${toPascalCase(m.name)}Result = ${returnType};`;
    })
    .join('\n');

  return {
    methods,
    interface: interfaceDef,
    implementations,
    types,
    returnTypes,
  };
}

/**
 * Convert a string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

/**
 * Generate an index file that exports all stores
 */
export function generateIndexFile(modules: ModuleMetadata[]): string {
  const exports = modules
    .map((module) => {
      const storeName = toPascalCase(module.name);
      const hookName = `use${storeName}Store`;
      return `export { ${hookName} } from './${module.name}';`;
    })
    .join('\n');

  return `// Generated by Modelence - DO NOT EDIT MANUALLY
/**
 * Auto-generated zustand stores for all modules
 * Import these stores in your client-side code to interact with the server
 */

${exports}
`;
}
